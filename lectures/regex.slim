= slide 'Regex' do
  blockquote Some people, when confronted with a problem, think “I know, I'll use regular expressions.” <br>Now they have two problems.

= slide 'Идея' do
  list:
    Вече би трябвало да я знаете от дискретни структури.
    Обикновено имаме голям стринг и искаме да извлечем информация от него.
    Писането на истински код за това би било бавно и досадно - тук идват на помощ регулярните изрази.
    Не са толкова страшни колкото си мислите.

= slide 'Basics' do
  list:
    `a` мачва символа a
    `.` мачва всеки символ
    `sasa` мачва стринга sasa
    `[abc]` мачва един символ, който е измежду a, b и c (това се нарича клас)
    `[a-zA-Z]` мачва един която и да е английска буква
    `\w` мачва буква, цифра или _
    `\d` мачва цифра (като [0-9])
    `\s` мачва какъквто и да е whitespace (интервали, нови редове, табулации)
    `(baba|sasa)` мачва думата baba или думата sasa (това се нарича група)
    можем да escape-ваме символи с \

= slide 'Quantifiers' do
  p Важат за непосредствено предхождащия ги символ/клас/група. Нека го означим с x.
  list:
    `x*` e нула или повече повторения на x.
    `x+` e едно или повече повторения на x.
    `x?` e нула или едно повторение на x.
    `x{m,n}` означава между m и n повторения на x, като можем да пропуснем единия край ако искаме (`{m,}` или `{,n}`)
    по default `+`, `*`, `{m,n}` са greedy - тоест ще поемат колкото се може повече символи - можем да ги накараме да искат минимален брой символи като сложим `?` след тях

= slide 'Advanced' do
  list:
    `[^abc]` е всеки символ различен от a, b и c
    `^` е началото на стринга, `$` е краят (те са с дължина 0)
    `\b` е граница между дума и недума (пак с дължина 0)
    `(sa|ba)_\1` тук `\1` мачва каквото е мачнала първата група тоест цялото ще е `sa_sa` или `ba_ba`
    `(?:sad)` слагането на `?:` кара групата да не се индексира (за примера по-горе и други ситуации)
    `ba(?=ba)` се нарича lookahead - това ще мачне ba, само когато е следвано от още едно ba
    `(?<=ba)ba` се нарича lookbehind - аналогично - само когато преди него е имало ba
    ако сложим `!` вместо `=` в последните две получаваме негативни look(ahead|behind) - мачва само когато условието не е изпълнено
    Последните 2 не се поддържат от всички езици.

= slide 'Още малко' do
  list:
    Доста езици имат литерален синтаксис за regex - например `/sasa/`
    тогава можем да имаме `/sasa/i` - i се нарича флаг
    i - case insensitive
    m - multiline - `^` и `$` мачват и начало и край на ред вместо само на целия стринг
    s - dotall - точката мачва и нови редове
    има и други флагове, но част от тях не всички флагове се поддържат от някои езици

= slide 'HTML5 форми' do
  list:
    Новите браузъри поддържат валидация дори от самия html - може да задавате регулярен израз в pattern атрибута
    Естествено можете да извършвате и валидация чрез javascript, php, java и тн.

= slide 'Заключение' do
  list:
    Има ги навсякъде.
    Добре е да ги научите.
    JS: `"baba".match(/BabA/i)`,  PHP: `preg_match("/BabA/i", "baba")`
    Обикновено във всеки език има методи за match, search, replace
    Също така обикновено можем да получавим обект или масив с мачнатите групи или пък директно да се съхранят в променливите `$1`, `$2` и тн.
    Какви точно са методите, чрез които да ги използвате на вашия език можете да намерите чрез google.